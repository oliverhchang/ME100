// File: code_Top_ESP32_Main.ino

#include <esp_now.h>
#include <WiFi.h>
#include "shared_struct.h" // Our shared command list

// *** REPLACE WITH YOUR BOTTOM ESP32's MAC ADDRESS ***
uint8_t bottomEsp32Address[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

// === 1. DEFINE YOUR STATE MACHINE ===
typedef enum {
  IDLE,
  DISPENSING_RICE,
  WASHING_CYCLE,
  FINAL_FILL,
  DROP_RICE_TO_POT,
  STARTING_COOKER,
  PROCESS_COMPLETE
} SystemState;

SystemState currentState = IDLE;
int washCycleCounter = 0;
const int MAX_WASH_CYCLES = 2; // How many times to wash?

// === 2. HARDWARE STUBS (Your code goes here) ===
// --- Silo ---
void openSilo(int siloNumber) { Serial.printf(">>> ACTION: Opening silo %d\n", siloNumber); }
void closeSilo(int siloNumber) { Serial.printf(">>> ACTION: Closing silo %d\n", siloNumber); }
float getRiceLevel(int siloNumber) { Serial.println(">>> SENSOR: Reading ultrasonic"); return 50.0; /* 50% full */ }

// --- Washing Basin ---
void startStirrer() { Serial.println(">>> ACTION: Starting stirrer motor"); }
void stopStirrer() { Serial.println(">>> ACTION: Stopping stirrer motor"); }
void openDrain() { Serial.println(">>> ACTION: Opening drain actuator"); }
void closeDrain() { Serial.println(">>> ACTION: Closing drain actuator"); }

// *** CRITICAL NOTE: You need actuators for water and dropping rice! ***
// You didn't list these, but your process requires them.
void openWaterValve() { Serial.println(">>> ACTION: Opening water valve (ASSUMED HARDWARE)"); }
void closeWaterValve() { Serial.println(">>> ACTION: Closing water valve (ASSUMED HARDWARE)"); }
void dropRiceIntoCooker() { Serial.println(">>> ACTION: Dropping rice into pot (ASSUMED HARDWARE)"); }


// --- Sensors ---
float getRiceWeight() { Serial.println(">>> SENSOR: Reading pressure sensor"); return 150.0; /* 150g */ }
float getWaterLevel() { Serial.println(">>> SENSOR: Reading moisture sensor"); return 2.0; /* 2cm */ }


// === 3. ESP-NOW FUNCTIONS ===
esp_now_peer_info_t peerInfo;
struct_message messageToSend;
struct_message messageToReceive;

void sendCommandToBottom(CommandType cmd) {
  messageToSend.command = cmd;
  esp_err_t result = esp_now_send(bottomEsp32Address, (uint8_t *) &messageToSend, sizeof(messageToSend));
  if (result != ESP_OK) { Serial.println("Error sending command to Bottom"); }
}

void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&messageToReceive, incomingData, sizeof(messageToReceive));
  Serial.print("Reply Received from Bottom: ");

  switch (messageToReceive.command) {
    case CMD_MANUAL_BUTTON_PRESSED:
      Serial.println("CMD_MANUAL_BUTTON_PRESSED");
      startCookingProcess(); // Trigger the main process
      break;
    case CMD_COOK_BUTTON_ACK:
      Serial.println("CMD_COOK_BUTTON_ACK");
      // Bottom confirms button was pressed. We can move to the final state.
      if (currentState == STARTING_COOKER) {
        currentState = PROCESS_COMPLETE;
      }
      break;
  }
}

// === 4. MAIN PROCESS LOGIC (THE STATE MACHINE) ===

// This is called by the web app OR the manual button
void startCookingProcess() {
  if (currentState == IDLE) {
    Serial.println("===== STARTING NEW COOKING PROCESS =====");
    currentState = DISPENSING_RICE;
    washCycleCounter = 0;
  } else {
    Serial.println("Process already running, ignoring request.");
  }
}

// ---- STATE 1: DISPENSE RICE ----
void handleDispensingState() {
  Serial.println("--- State: DISPENSING_RICE ---");
  openSilo(1); // Example: use silo 1
  
  // TODO: This should be non-blocking, but for a skeleton:
  while (getRiceWeight() < 150.0) { // Target: 150g
    delay(100);
  }
  
  closeSilo(1);
  Serial.println("Rice dispensed.");
  currentState = WASHING_CYCLE; // Move to next state
}

// ---- STATE 2: WASH RICE ----
void handleWashingState() {
  Serial.printf("--- State: WASHING_CYCLE (Cycle %d) ---\n", washCycleCounter + 1);
  
  // 1. Fill
  Serial.println("Filling with water...");
  openWaterValve();
  while (getWaterLevel() < 3.0) { // Target: 3cm
    delay(100);
  }
  closeWaterValve();

  // 2. Stir
  Serial.println("Stirring...");
  startStirrer();
  delay(10000); // Stir for 10 seconds
  stopStirrer();

  // 3. Drain
  Serial.println("Draining...");
  openDrain();
  while (getWaterLevel() > 0.5) { // Wait until empty
    delay(100);
  }
  closeDrain();
  Serial.println("Drain complete.");

  // 4. Check if done
  washCycleCounter++;
  if (washCycleCounter >= MAX_WASH_CYCLES) {
    currentState = FINAL_FILL; // Done washing, move to next state
  } else {
    currentState = WASHING_CYCLE; // Loop back to this state
  }
}

// ---- STATE 3: FINAL WATER FILL ----
void handleFinalFillState() {
  Serial.println("--- State: FINAL_FILL ---");
  Serial.println("Adding final water for cooking...");
  openWaterValve();
  // Use pressure sensor to get correct rice-to-water ratio
  float targetWeight = getRiceWeight() * 2.5; // Example: 1:1.5 ratio by weight
  while (getRiceWeight() < targetWeight) {
    delay(100);
  }
  closeWaterValve();
  Serial.println("Final water added.");
  currentState = DROP_RICE_TO_POT; // Move to next state
}

// ---- STATE 4: DROP RICE ----
void handleDropRiceState() {
  Serial.println("--- State: DROP_RICE_TO_POT ---");
  dropRiceIntoCooker(); // This is your assumed mechanism
  delay(5000); // Give it 5s to drop
  Serial.println("Rice dropped into cooker.");
  currentState = STARTING_COOKER; // Move to next state
}

// ---- STATE 5: START COOKER ----
void handleStartCookerState() {
  Serial.println("--- State: STARTING_COOKER ---");
  Serial.println("Sending command to Bottom ESP32 to press cook button...");
  sendCommandToBottom(CMD_PRESS_COOK_BUTTON);
  // The state will be changed to PROCESS_COMPLETE by the OnDataRecv
  // function when it gets the ACK.
}

// ---- STATE 6: COMPLETE ----
void handleCompleteState() {
  Serial.println("===== PROCESS COMPLETE! =====");
  // Reset for next time
  currentState = IDLE;
}

// === 5. SETUP & LOOP ===

void setup() {
  Serial.begin(115200);
  
  // Set device as a Wi-Fi Station (needed for ESP-NOW & Web App)
  WiFi.mode(WIFI_STA);
  // TODO: Add your WiFi.begin(ssid, password) here for the web app
  
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  // Register peer (Bottom ESP32)
  memcpy(peerInfo.peer_addr, bottomEsp32Address, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  if (esp_now_add_peer(&peerInfo) != OK) {
    Serial.println("Failed to add peer");
    return;
  }
  // Register receive callback
  esp_now_register_recv_cb(OnDataRecv);

  Serial.println("Top ESP32 (Main) Ready.");
}

void loop() {
  // This is the main state machine runner
  switch (currentState) {
    case IDLE:
      // Do nothing, wait for a trigger
      break;
    case DISPENSING_RICE:
      handleDispensingState();
      break;
    case WASHING_CYCLE:
      handleWashingState();
      break;
    case FINAL_FILL:
      handleFinalFillState();
      break;
    case DROP_RICE_TO_POT:
      handleDropRiceState();
      break;
    case STARTING_COOKER:
      handleStartCookerState();
      break;
    case PROCESS_COMPLETE:
      handleCompleteState();
      break;
  }

  // TODO: Add your web app check here
  // e.g., if (webApp.commandReceived() == "start") {
  //   startCookingProcess();
  // }
  
  delay(100); // Main loop delay
}
