// File: code_Main_ESP32_Machine.ino

#include <esp_now.h>
#include <WiFi.h>
#include "shared_struct.h" // Our shared command list

// === 1. GLOBAL SETTINGS (Set by Remote) ===
int targetRiceType = 1;
float targetPortionGrams = 150.0;

// === 2. DEFINE YOUR STATE MACHINE ===
typedef enum {
  IDLE,
  DISPENSING_RICE,
  WASHING_CYCLE,
  FINAL_FILL,
  DROP_RICE_TO_POT,
  STARTING_COOKER,
  PROCESS_COMPLETE
} SystemState;

SystemState currentState = IDLE;
int washCycleCounter = 0;
const int MAX_WASH_CYCLES = 2; // How many times to wash?

// === 3. HARDWARE STUBS (Your code goes here) ===
// --- Silos (Actuators) ---
void openSilo(int siloNumber) { Serial.printf(">>> ACTION: Opening silo %d\n", siloNumber); }
void closeSilo(int siloNumber) { Serial.printf(">>> ACTION: Closing silo %d\n", siloNumber); }
// --- Silos (Sensors) ---
float getRiceLevel(int siloNumber) { Serial.println(">>> SENSOR: Reading ultrasonic"); return 50.0; /* 50% full */ }

// --- Washing Basin (Actuators) ---
void startStirrer() { Serial.println(">>> ACTION: Starting stirrer motor"); }
void stopStirrer() { Serial.println(">>> ACTION: Stopping stirrer motor"); }
void openDrain() { Serial.println(">>> ACTION: Opening drain actuator"); }
void closeDrain() { Serial.println(">>> ACTION: Closing drain actuator"); }
void openWaterValve() { Serial.println(">>> ACTION: Opening water valve"); }
void closeWaterValve() { Serial.println(">>> ACTION: Closing water valve"); }
void dropRiceIntoCooker() { Serial.println(">>> ACTION: Dropping rice into pot"); }

// --- Washing Basin (Sensors) ---
float getRiceWeight() { Serial.println(">>> SENSOR: Reading pressure sensor"); return 150.0; /* 150g */ }
float getWaterLevel() { Serial.println(">>> SENSOR: Reading moisture sensor"); return 2.0; /* 2cm */ }

// --- Cooker (Actuator) ---
void pressCookerButton() {
  Serial.println(">>> ACTION: Pressing cook button servo...");
  // TODO: Add your servo code here
  // myCookServo.write(90); delay(500); myCookServo.write(0);
}


// === 4. ESP-NOW FUNCTIONS ===
struct_message messageToReceive;

// Callback when data is received from Controller
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&messageToReceive, incomingData, sizeof(messageToReceive));
  Serial.print("Command Received: ");

  switch (messageToReceive.command) {
    case CMD_START_PROCESS:
      Serial.println("CMD_START_PROCESS");
      startCookingProcess(); // Trigger the main process
      break;
    
    case CMD_SELECT_RICE_TYPE:
      targetRiceType = messageToReceive.value;
      Serial.printf("Setting rice type to %d\n", targetRiceType);
      break;

    case CMD_SET_PORTION:
      targetPortionGrams = (float)messageToReceive.value;
      Serial.printf("Setting portion to %.0fg\n", targetPortionGrams);
      break;
    
    case CMD_PAUSE_PROCESS:
      Serial.println("CMD_PAUSE_PROCESS");
      // TODO: Add logic to pause
      // currentState = PAUSED;
      break;
  }
}

// === 5. MAIN PROCESS LOGIC (THE STATE MACHINE) ===

// This is called by the remote
void startCookingProcess() {
  if (currentState == IDLE) {
    Serial.println("===== STARTING NEW COOKING PROCESS =====");
    Serial.printf("Target: %.0fg of rice type %d\n", targetPortionGrams, targetRiceType);
    currentState = DISPENSING_RICE;
    washCycleCounter = 0;
  } else {
    Serial.println("Process already running, ignoring request.");
  }
}

// ---- STATE 1: DISPENSE RICE ----
void handleDispensingState() {
  Serial.println("--- State: DISPENSING_RICE ---");
  openSilo(targetRiceType); // Use the correct silo
  
  // TODO: This should be non-blocking, but for a skeleton:
  while (getRiceWeight() < targetPortionGrams) {
    delay(100);
  }
  
  closeSilo(targetRiceType);
  Serial.println("Rice dispensed.");
  currentState = WASHING_CYCLE; // Move to next state
}

// ---- STATE 2: WASH RICE ----
void handleWashingState() {
  Serial.printf("--- State: WASHING_CYCLE (Cycle %d) ---\n", washCycleCounter + 1);
  
  // 1. Fill
  Serial.println("Filling with water...");
  openWaterValve();
  while (getWaterLevel() < 3.0) { delay(100); } // Target: 3cm
  closeWaterValve();

  // 2. Stir
  Serial.println("Stirring...");
  startStirrer();
  delay(10000); // Stir for 10 seconds
  stopStirrer();

  // 3. Drain
  Serial.println("Draining...");
  openDrain();
  while (getWaterLevel() > 0.5) { delay(100); } // Wait until empty
  closeDrain();
  Serial.println("Drain complete.");

  // 4. Check if done
  washCycleCounter++;
  if (washCycleCounter >= MAX_WASH_CYCLES) {
    currentState = FINAL_FILL; // Done washing
  }
  // else: loop will run this state again
}

// ---- STATE 3: FINAL WATER FILL ----
void handleFinalFillState() {
  Serial.println("--- State: FINAL_FILL ---");
  Serial.println("Adding final water for cooking...");
  openWaterValve();
  
  // Use pressure sensor to get correct rice-to-water ratio
  float currentWeight = getRiceWeight();
  float finalWeight = currentWeight * 2.5; // Example: 1:1.5 water ratio (Total = 1 part rice + 1.5 parts water)
  
  while (getRiceWeight() < finalWeight) {
    delay(100);
  }
  closeWaterValve();
  Serial.println("Final water added.");
  currentState = DROP_RICE_TO_POT; // Move to next state
}

// ---- STATE 4: DROP RICE ----
void handleDropRiceState() {
  Serial.println("--- State: DROP_RICE_TO_POT ---");
  dropRiceIntoCooker(); // This is your mechanism
  delay(5000); // Give it 5s to drop
  Serial.println("Rice dropped into cooker.");
  currentState = STARTING_COOKER; // Move to next state
}

// ---- STATE 5: START COOKER ----
void handleStartCookerState() {
  Serial.println("--- State: STARTING_COOKER ---");
  pressCookerButton();
  delay(1000); // Wait 1s for servo
  Serial.println("Cooker started.");
  currentState = PROCESS_COMPLETE; // Move to final state
}

// ---- STATE 6: COMPLETE ----
void handleCompleteState() {
  Serial.println("===== PROCESS COMPLETE! =====");
  // Reset for next time
  currentState = IDLE;
}

// === 6. SETUP & LOOP ===

void setup() {
  Serial.begin(115200);
  
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  // NOTE: You can ALSO connect to your home Wi-Fi here if you
  // still want the web app functionality. ESP-NOW and Wi-Fi
  // can run at the same time.
  // WiFi.begin(ssid, password);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Register the receive callback
  esp_now_register_recv_cb(OnDataRecv);
  Serial.println("Main ESP32 (Machine) Ready and listening.");
}

void loop() {
  // This is the main state machine runner
  switch (currentState) {
    case IDLE:
      // Do nothing, wait for a trigger
      break;
    case DISPENSING_RICE:
      handleDispensingState();
      break;
    case WASHING_CYCLE:
      handleWashingState();
      break;
    case FINAL_FILL:
      handleFinalFillState();
      break;
    case DROP_RICE_TO_POT:
      handleDropRiceState();
      break;
    case STARTING_COOKER:
      handleStartCookerState();
      break;
    case PROCESS_COMPLETE:
      handleCompleteState();
      break;
  }
  
  delay(100); // Main loop delay
}
